<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>移动端蜘蛛网模拟</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; }
        body { 
            margin: 0; 
            background-color: #ffffff; 
            overflow: hidden; 
            /* 防止手机浏览器默认的下拉刷新和左右滑动翻页 */
            touch-action: none; 
            position: fixed;
            width: 100%;
            height: 100%;
        }
        canvas { display: block; }
        .hint {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; color: rgba(0,0,0,0.2);
            font-family: sans-serif; font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="hint">手指拖拽网格节点以拉断 // TOUCH & DRAG</div>
    <canvas id="webCanvas"></canvas>

<script>
const config = {
    // 手机端建议降低一点密度以保证 60fps 流畅度
    resX: 60,            
    resY: 80,            
    stiffness: 0.9,      
    friction: 0.95,      
    breakThreshold: 3.2, 
    grabRadius: 50       // 手机端手指较粗，判定范围稍微调大
};

const canvas = document.getElementById('webCanvas');
const ctx = canvas.getContext('2d');

let points = [];
let constraints = [];
let width, height;
let grabbedPoint = null;

class Point {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.px = x; this.py = y;
        this.pinned = false;
    }
    update() {
        if (this.pinned || this === grabbedPoint) return;
        let vx = (this.x - this.px) * config.friction;
        let vy = (this.y - this.py) * config.friction;
        this.px = this.x; this.py = this.y;
        this.x += vx; this.y += vy;
    }
}

class Constraint {
    constructor(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
        this.initialDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        this.limit = this.initialDist * (config.breakThreshold + Math.random() * 0.4);
        this.broken = false;
    }
    resolve() {
        if (this.broken) return;
        const dx = this.p2.x - this.p1.x;
        const dy = this.p2.y - this.p1.y;
        const dist = Math.hypot(dx, dy);
        if (dist > this.limit) { this.broken = true; return; }
        const diff = (this.initialDist - dist) / dist;
        const mul = diff * config.stiffness * 0.5;
        const offsetX = dx * mul; const offsetY = dy * mul;
        if (!this.p1.pinned && this.p1 !== grabbedPoint) { this.p1.x -= offsetX; this.p1.y -= offsetY; }
        if (!this.p2.pinned && this.p2 !== grabbedPoint) { this.p2.x += offsetX; this.p2.y += offsetY; }
    }
}

function init() {
    // 处理高像素比屏幕，防止线条模糊
    const dpr = window.devicePixelRatio || 1;
    width = canvas.width = window.innerWidth * dpr;
    height = canvas.height = window.innerHeight * dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';

    points = [];
    constraints = [];
    const spX = window.innerWidth / (config.resX - 1);
    const spY = window.innerHeight / (config.resY - 1);

    for (let y = 0; y < config.resY; y++) {
        for (let x = 0; x < config.resX; x++) {
            let p = new Point(x * spX, y * spY);
            if (x === 0 || x === config.resX - 1 || y === 0 || y === config.resY - 1) p.pinned = true;
            points.push(p);
        }
    }
    for (let y = 0; y < config.resY; y++) {
        for (let x = 0; x < config.resX; x++) {
            if (x < config.resX - 1) constraints.push(new Constraint(points[y * config.resX + x], points[y * config.resX + x + 1]));
            if (y < config.resY - 1) constraints.push(new Constraint(points[y * config.resX + x], points[(y + 1) * config.resX + x]));
        }
    }
}

// 统一交互处理函数
function handleStart(clientX, clientY) {
    let closest = null;
    let minDist = config.grabRadius;
    for (let p of points) {
        const d = Math.hypot(p.x - clientX, p.y - clientY);
        if (d < minDist) { minDist = d; closest = p; }
    }
    if (closest) grabbedPoint = closest;
}

function handleMove(clientX, clientY) {
    if (grabbedPoint) {
        grabbedPoint.x = clientX;
        grabbedPoint.y = clientY;
        grabbedPoint.px = clientX;
        grabbedPoint.py = clientY;
    }
}

// 事件监听
window.addEventListener('touchstart', e => { handleStart(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, {passive: false});
window.addEventListener('touchmove', e => { handleMove(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, {passive: false});
window.addEventListener('touchend', () => { grabbedPoint = null; });

// 同时也保留鼠标支持
window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
window.addEventListener('mouseup', () => grabbedPoint = null);

function update() {
    points.forEach(p => p.update());
    for (let i = 0; i < 5; i++) constraints.forEach(c => c.resolve());
}

function draw() {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
    ctx.beginPath();
    ctx.lineWidth = 0.4;
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    for (let c of constraints) {
        if (!c.broken) {
            ctx.moveTo(c.p1.x, c.p1.y);
            ctx.lineTo(c.p2.x, c.p2.y);
        }
    }
    ctx.stroke();
}

function loop() {
    update(); draw();
    requestAnimationFrame(loop);
}

window.addEventListener('resize', init);
init();
loop();
</script>
</body>
</html>