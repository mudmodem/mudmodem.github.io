<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>撕碎</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; touch-action: none; }
        body { 
            margin: 0; padding: 0; background-color: #ffffff; 
            overflow: hidden; position: fixed; width: 100%; height: 100%;
        }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="webCanvas"></canvas>

<script>
const config = {
    // 增加密度：resX 和 resY 调高
    resX: 100,            
    resY: 100,            
    stiffness: 0.75,      
    friction: 0.95,      
    baseBreakThreshold: 8.0, 
    protectRadius: 100,    
    randomBreakChance: 0.1, 
    recoilStrength: 1.5,    
    maxColorStretch: 20  // 颜色变化的灵敏度
};

const canvas = document.getElementById('webCanvas');
const ctx = canvas.getContext('2d');

let points = [];
let constraints = [];
let width, height;
let grabbedPoint = null;
let curX = 0, curY = 0;

/**
 * 高级感设计师配色：
 * 正常状态：低饱和度彩灰色 (HSL 180, 5, 45)
 * 受力状态：色相跨越 青 -> 蓝 -> 紫 -> 桃红
 */
function getStressColor(stretchRatio) {
    if (stretchRatio <= 0.05) return '#777777'; // 静止时为纯粹的中灰色
    
    // 随着拉伸，色相从 190 (青) 变到 320 (洋红)，饱和度从 10% 提升到 90%
    const h = 190 + (130 * stretchRatio); 
    const s = 10 + (80 * stretchRatio);
    const l = 45 + (15 * stretchRatio);
    
    return `hsl(${h}, ${s}%, ${l}%)`;
}

class Point {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.px = x; this.py = y;
        this.pinned = false;
    }
    update() {
        if (this.pinned || this === grabbedPoint) return;
        let vx = (this.x - this.px) * config.friction;
        let vy = (this.y - this.py) * config.friction;
        this.px = this.x; this.py = this.y;
        this.x += vx; this.y += vy;
    }
}

class Constraint {
    constructor(p1, p2) {
        this.p1 = p1; this.p2 = p2;
        this.initialDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        this.broken = false;
        
        // 记录垂直梯度：用于实现顶端强韧、底端脆化
        const avgY = (p1.y + p2.y) / 2;
        this.yWeight = avgY / window.innerHeight; 
    }
    resolve() {
        if (this.broken) return;
        const dx = this.p2.x - this.p1.x;
        const dy = this.p2.y - this.p1.y;
        const d = Math.hypot(dx, dy);
        
        if (grabbedPoint) {
            const centerX = (this.p1.x + this.p2.x) / 2;
            const centerY = (this.p1.y + this.p2.y) / 2;
            const distToFinger = Math.hypot(centerX - curX, centerY - curY);

            // 1. 破碎逻辑 (受 y 轴影响)
            if (distToFinger > config.protectRadius) {
                // 顶端 localThreshold 会非常大（不容易碎），底部 localThreshold 趋近 base
                const localThreshold = config.baseBreakThreshold * (4.0 - this.yWeight * 3.2);
                
                if (d > this.initialDist * localThreshold) {
                    if (Math.random() < config.randomBreakChance) {
                        this.broken = true;
                        const s = config.recoilStrength;
                        if (!this.p1.pinned) { this.p1.x -= dx * s; this.p1.y -= dy * s; }
                        if (!this.p2.pinned) { this.p2.x += dx * s; this.p2.y += dy * s; }
                        return;
                    }
                }
            }
        }

        // 物理拉力约束
        const diff = (this.initialDist - d) / d;
        const m = diff * config.stiffness * 0.5;
        const ox = dx * m; const oy = dy * m;
        if (!this.p1.pinned && this.p1 !== grabbedPoint) { this.p1.x -= ox; this.p1.y -= oy; }
        if (!this.p2.pinned && this.p2 !== grabbedPoint) { this.p2.x += ox; this.p2.y += oy; }
    }
}

function init() {
    const dpr = window.devicePixelRatio || 1;
    width = window.innerWidth; height = window.innerHeight;
    canvas.width = width * dpr; canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    
    points = []; constraints = [];
    const spX = width / (config.resX - 1);
    const spY = height / (config.resY - 1);

    for (let y = 0; y < config.resY; y++) {
        for (let x = 0; x < config.resX; x++) {
            let p = new Point(x * spX, y * spY);
            // 锁定最顶端和最底端的边缘点
            if (x === 0 || x === config.resX - 1 || y === 0 || y === config.resY - 1) p.pinned = true;
            points.push(p);
        }
    }
    
    for (let y = 0; y < config.resY; y++) {
        for (let x = 0; x < config.resX; x++) {
            if (x < config.resX - 1) constraints.push(new Constraint(points[y*config.resX+x], points[y*config.resX+x+1]));
            if (y < config.resY - 1) constraints.push(new Constraint(points[y*config.resX+x], points[(y+1)*config.resX+x]));
        }
    }
}

function onStart(e) {
    const t = e.touches ? e.touches[0] : e;
    curX = t.clientX; curY = t.clientY;
    let minDist = 80; grabbedPoint = null;
    for (let p of points) {
        const d = Math.hypot(p.x - curX, p.y - curY);
        if (d < minDist) { minDist = d; grabbedPoint = p; }
    }
}

function onMove(e) {
    const t = e.touches ? e.touches[0] : e;
    curX = t.clientX; curY = t.clientY;
    if (e.touches) e.preventDefault();
}

canvas.addEventListener('touchstart', onStart, {passive: false});
window.addEventListener('touchmove', onMove, {passive: false});
window.addEventListener('touchend', () => { grabbedPoint = null; });
canvas.addEventListener('mousedown', onStart);
window.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', () => { grabbedPoint = null; });
window.addEventListener('dblclick', init); 

function update() {
    if (grabbedPoint) {
        grabbedPoint.x = curX; grabbedPoint.y = curY;
        grabbedPoint.px = curX; grabbedPoint.py = curY;
    }
    points.forEach(p => p.update());
    for (let i = 0; i < 7; i++) constraints.forEach(c => c.resolve());
}

function draw() {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, width, height);
    
    // 线条宽度随密度自动调整
    ctx.lineWidth = 0.7; 

    for (let c of constraints) {
        if (!c.broken) {
            const d = Math.hypot(c.p1.x - c.p2.x, c.p1.y - c.p2.y);
            // 计算拉伸比率 (0到1)，用于色彩映射
            const stretch = Math.min(1, Math.max(0, d - c.initialDist) / config.maxColorStretch);
            
            ctx.strokeStyle = getStressColor(stretch);
            ctx.beginPath();
            ctx.moveTo(c.p1.x, c.p1.y);
            ctx.lineTo(c.p2.x, c.p2.y);
            ctx.stroke();
        }
    }
    requestAnimationFrame(() => { update(); draw(); });
}

window.addEventListener('resize', init);
init();
draw();
</script>
</body>
</html>
